"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Paper75HDB = void 0;
const rpio_1 = require("rpio");
const pin_1 = require("./pin");
/**
 * A 7.5inch HD (B) device implementation.
 */
class Paper75HDB {
    constructor() {
        this.width = 880;
        this.height = 528;
    }
    initialize() {
        (0, rpio_1.init)({
            gpiomem: false,
            mapping: "gpio",
        });
        (0, rpio_1.mode)(pin_1.Pin.RST, rpio_1.OUTPUT);
        (0, rpio_1.mode)(pin_1.Pin.DC, rpio_1.OUTPUT);
        (0, rpio_1.mode)(pin_1.Pin.CS, rpio_1.OUTPUT);
        (0, rpio_1.mode)(pin_1.Pin.BUSY, rpio_1.INPUT);
        (0, rpio_1.write)(pin_1.Pin.CS, 1);
        (0, rpio_1.spiBegin)();
        (0, rpio_1.spiSetDataMode)(0);
        (0, rpio_1.spiSetClockDivider)(128);
        (0, rpio_1.spiChipSelect)(0);
        (0, rpio_1.spiSetCSPolarity)(0, rpio_1.LOW);
        this.reset();
        this.command(0x12);
        this.waitUntilIdle();
        this.command(0x46);
        this.data(0xf7);
        this.waitUntilIdle();
        this.command(0x47);
        this.data(0xf7);
        this.waitUntilIdle();
        this.command(0x0c);
        this.data(0xae, 0xc7, 0xc3, 0xc0, 0x40);
        this.command(0x01);
        this.data(0xaf, 0x02, 0x01);
        this.command(0x11);
        this.data(0x01);
        this.command(0x44);
        this.data(0x00, 0x00, 0x6f, 0x03);
        this.command(0x45);
        this.data(0xaf, 0x02, 0x00, 0x00);
        this.command(0x3c);
        this.data(0x01);
        this.command(0x18);
        this.data(0x80);
        this.command(0x22);
        this.data(0xb1);
        this.command(0x20);
        this.waitUntilIdle();
        this.command(0x4e);
        this.data(0x00, 0x00);
        this.command(0x4f);
        this.data(0xaf, 0x02);
    }
    finalize() {
        this.deviceSleep();
        (0, rpio_1.msleep)(2000);
        (0, rpio_1.write)(pin_1.Pin.CS, rpio_1.LOW);
        (0, rpio_1.write)(pin_1.Pin.DC, rpio_1.LOW);
        (0, rpio_1.write)(pin_1.Pin.RST, rpio_1.LOW);
        (0, rpio_1.spiEnd)();
        (0, rpio_1.exit)();
    }
    draw(blackPixels, redPixels) {
        this.command(0x4f);
        this.data(0xaf, 0x02);
        this.command(0x24);
        this.data(...blackPixels);
        this.command(0x26);
        this.data(...redPixels);
        this.displayOn();
    }
    displayOn() {
        this.command(0x22);
        this.data(0xc7); // Load LUT from MCU(0x32)
        this.command(0x20);
        (0, rpio_1.msleep)(200); // !!!The rpio.msleep here is necessary, 200uS at least!!!
        this.waitUntilIdle();
    }
    deviceSleep() {
        this.command(0x10);
        this.data(0x01);
    }
    reset() {
        (0, rpio_1.write)(pin_1.Pin.RST, 1);
        (0, rpio_1.msleep)(200);
        (0, rpio_1.write)(pin_1.Pin.RST, 0);
        (0, rpio_1.msleep)(2);
        (0, rpio_1.write)(pin_1.Pin.RST, 1);
        (0, rpio_1.msleep)(200);
    }
    command(id) {
        (0, rpio_1.write)(pin_1.Pin.DC, 0);
        (0, rpio_1.write)(pin_1.Pin.CS, 0);
        (0, rpio_1.spiWrite)(Buffer.alloc(1, id), 1);
        (0, rpio_1.write)(pin_1.Pin.CS, 1);
    }
    data(...data) {
        (0, rpio_1.write)(pin_1.Pin.CS, 0);
        (0, rpio_1.write)(pin_1.Pin.DC, 1);
        (0, rpio_1.spiWrite)(Buffer.from(data), data.length);
        (0, rpio_1.write)(pin_1.Pin.CS, 1);
    }
    waitUntilIdle() {
        while ((0, rpio_1.read)(pin_1.Pin.BUSY)) {
            (0, rpio_1.msleep)(10);
        }
        (0, rpio_1.msleep)(200);
    }
}
exports.Paper75HDB = Paper75HDB;
//# sourceMappingURL=paper75HDB.js.map