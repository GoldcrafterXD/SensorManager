"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Drawer = void 0;
const tslib_1 = require("tslib");
const image_pixels_1 = (0, tslib_1.__importDefault)(require("image-pixels"));
const svg_render_1 = (0, tslib_1.__importDefault)(require("svg-render"));
/**
 * Class for high-level drawing on a device.
 */
class Drawer {
    /**
     * Creates a Drawer instance.
     * @param device specific device implementation to be used as an underlying hardware for drawing to
     */
    constructor(device) {
        this.device = device;
    }
    /**
     * Clears the device.
     */
    clear() {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const length = (this.device.width * this.device.height) / 8; // TODO handle fractions
            const blackPixels = Array(length).fill(0xff);
            const redPixels = Array(length).fill(0);
            this.device.draw(blackPixels, redPixels);
        });
    }
    /**
     * Draws a svg image on the device.
     * @param svg A svg which is to be drawed to the device. The size of svg's viewport should match the device size. If bigger, it will be clipped.
     */
    drawSvg(svg) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const outputBuffer = yield (0, svg_render_1.default)({
                buffer: Buffer.from(svg, "utf-8"),
                width: this.device.width,
                height: this.device.height,
            });
            const { data } = yield (0, image_pixels_1.default)(outputBuffer);
            const blackBytes = [];
            const redBytes = [];
            let offset = 128;
            let blackByte = 0;
            let redByte = 0;
            for (let i = 0; i < data.length; i += 4) {
                const [r, g, b, a] = data.slice(i, i + 4);
                const isBlack = r === 0 && g === 0 && b === 0 && a === 255;
                const isRed = r === 255 && g === 0 && b === 0 && a === 255;
                blackByte += isBlack ? 0 : offset;
                redByte += isRed ? 0 : offset;
                offset = offset >> 1;
                if (offset === 0) {
                    blackBytes.push(blackByte);
                    redBytes.push(redByte ^ 0xff);
                    blackByte = 0;
                    redByte = 0;
                    offset = 128;
                }
            }
            this.device.draw(blackBytes, redBytes);
        });
    }
}
exports.Drawer = Drawer;
//# sourceMappingURL=drawer.js.map